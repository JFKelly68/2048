<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 Clone</title>
  <style>
    .grid-3x3 {
      display: grid;
      grid-template-columns: 1fr 5fr 1fr;
      grid-template-rows: 1fr 5fr 1fr;
    }

    .top-m,
    .mid-l,
    .mid-r,
    .bot-m {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(4, minmax(100px, 1fr));
      grid-auto-rows: minmax(100px, auto);
    }

    .point {
      display: grid;
      align-items: center;
      justify-items: center;
      border: 1px solid #000;
    }
    
    .swipe {
      position: relative;
      width: 80px;
      height: 40px;
    }

    .swipe::after {
      content: '^';
      display: flex;
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      align-items: center;
      justify-content: center;
      transform-origin: center;
    }

    .swipe-l {
      transform: rotate(-90deg);
    }
    .swipe-r {
      transform: rotate(90deg);
    }
    .swipe-d {
      transform: rotate(180deg);
    }

    header,
    footer {
      text-align: center;
    }

    div[value="2"] {
      background-color: rgb(240, 240, 240);
    }
    div[value="4"] {
      background-color: beige;
    }
    div[value="8"] {
      background-color: yellow;
    }
    div[value="16"] {
      background-color: rgb(215, 185, 110);
    }
    div[value="32"] {
      background-color: orange;
    }
    div[value="64"] {
      background-color: rgb(255, 125, 33);
    }
    div[value="128"] {
      background-color: rgb(26, 215, 221);
    }
    div[value="256"] {
      background-color: rgb(0, 255, 166);
    }
    div[value="512"] {
      background-color: rgb(17, 189, 40);
    }
    div[value="1024"] {
      background-color: rgb(20, 129, 7);
    }
    div[value="2048"] {
      background-color: rgb(252, 0, 0);
    }
  </style>
</head>
<body>
  <article>
    <header>
      <h1>
        This is a clone 2048 game
      </h1>
    </header>
    <section id="main" class="grid-3x3">
      <div class="top-l"></div>
      <div class="top-m">
        <button type="button" class="btn swipe swipe-u js-swipe-btn" id="swipe-up" value="up"></button>
      </div>
      <div class="top-r"></div>
      <div class="mid-l">
        <!-- BOARD goes here -->
        <button type="button" class="btn swipe swipe-l js-swipe-btn" id="swipe-left" value="left"></button>
      </div>
      <div class="mid-m">
        <div id="board" class="board"></div>
      </div>
      <div class="mid-r">
        <button type="button" class="btn swipe swipe-r js-swipe-btn" id="swipe-right" value="right"></button>
      </div>
      <div class="bot-l"></div>
      <div class="bot-m">
        <button type="button" class="btn swipe swipe-d js-swipe-btn" id="swipe-down" value="down"></button>
      </div>
      <div class="bot-r"></div>
      <!-- https://developer.mozilla.org/en-US/docs/Web/Web_Components -->
      <custom-modal title="You fucking lost, idiot." description="Maybe don't suck so much? ¯\(ツ)/¯" class="js-modal-lost">
        <!-- TODO: implement other options for lose state -->
        <button type="button" id="reset" class="btn reset js-reset-btn">Start Over</button>
      </custom-modal>
    </section>
    <footer>
      <!-- reset button -->
      <button type="button" id="reset" class="btn reset js-reset-btn">Reset</button>
    </footer>
  </article>
  
  <script src="modal.js"></script>
  <script type="text/javascript">
    // TODO: refactor to make each component a WebComponent
    // TODO: refactor to pull more game logic into App (modal ctrl, end/lose state, "progress" board, etc)
    // UTILS
    const compose = (a, b) => x => a(b(x));
    const reverse = array => [...array].reverse();
    const flipMatrix = matrix => (
      matrix[0].map((column, index) => (
        matrix.map(row => row[index])
      ))
    );
    const rotateMatrixClockwise = compose(flipMatrix, reverse);
    const rotateMatrixCounterClockwise = compose(reverse, flipMatrix)
    const rotateMatrixDouble = compose(rotateMatrixClockwise, rotateMatrixClockwise);

    class Point {
      static get className () {
        return 'point';
      }

      static makeElement () {
        const el = document.createElement('div');
        el.classList.add(`${this.className}`);
        return el;
      }

      static get emptyValues () {
        return {
          display: '',
          attribute: 'empty',
          value: null // don't make this a number
        };
      }

      constructor (val) {
        this.element = this.constructor.makeElement();
        this.render(val);
      }

      render (value) {
        this.element.setAttribute('value', value || this.constructor.emptyValues.attribute);
        this.element.innerText = value || this.constructor.emptyValues.display;
      }
    }

    class Board {
      static get className () {
        return 'board'
      }

      static get selector () {
        return `#${this.className}`;
      }

      static resetData (size = 4) {
        // NOTE: create square matrix
        return Array.from({length: size}, () => Array.from({length: size}, () => Math.random() > 0.8 ? 2 : null)) // initialize grid with 2's or null
      }

      static modalEvt = 'MODAL';
      
      constructor (initData) {
        this.element = document.querySelector(this.constructor.selector);
        this.modal = document.querySelector('.js-modal-lost');
        this._data = initData;
        this._points = [];

        this._init();
      }

      get data () {
        // NOTE: could set this to always return a copy of the _data matrix, but that might be a performance concern
        return this._data;
      }

      set data (newState) {
        this._data = newState;
      }
      
      // PRIVATE METHODS
      _init () {
        if (!this._data) this._data = this.constructor.resetData(); // only update _data if none initialized
        if (!this.element.children.length) this._makeGrid();
        this.render();
      }

      _introduce () {
        // take the existing data and add a new 2 or 4 to an available slot
        const newNum = Math.random() > 0.4 ? 2 : 4; // trend towards 2s
        const availableSpaces = this._assessAvailable();
        const idx = Math.round(Math.random() * availableSpaces.length) % availableSpaces.length; // random int based on # of available spaces
        const [x,y] = availableSpaces[idx]; // get matrix coordinates of available space chosen at random
        this._data[x][y] = newNum;
      }

      _assessAvailable () {
        const availableSpaces = [];
        
        for (let i = 0; i < this._data.length; i++) {
          for (let j = 0; j < this._data.length; j++) {
            if (this._data[i][j] === Point.emptyValues.value) availableSpaces.push([i,j]);
          }
        }

        return availableSpaces;
      }

      _rebuild () {
        this._deleteGrid();
        this.reset();
      }

      _deleteGrid () {
        if (this.element.children.length) [].slice.call(this.element.children).forEach(el => el.remove());
      }

      _makeGrid () {
        this._deleteGrid();
        const points = this._data.flat().map(val => new Point(val))
        this.element.append(...points.map(p => p.element));
        this._points = points;
      }
      
      
      /* NOTE: previous, naive implementation (does not work for instance such as [2,0,2,0])
        for (let i = 0; i < row.length; i++) {
          if (!row[i]) continue; // if it's 0, skip
          if (row[i] == row[i+1]) {
            out.push(row[i] + row[i+1]);
            i++;
          }
          else {
            out.push(row[i]);
          }
        }
      */
      _mergeRow (row) {
        const out = [];
        let l = 0, r = 1; // 2 pointers

        /* NOTE: O(n) I believe, single-pass consolidation
          increment r and compare to l
          we don't care about nulls, so while r == null, increment
          if l === r
            push sum to output
            move l to right of r
            move r+1
          else (l !== r)
            if l !== null && !undefined (i.e. !out of bounds)
              push l to output
              increment l
            (because we don't care about 0s) while l == null, increment
            increment r
        */  
        while (l < row.length) {
          while (row[r] === Point.emptyValues.value) r++;
          if (row[l] === row[r]) {
            out.push(row[l] + row[r]);
            l = ++r;
            r++;
          } else {
            if (row[l] !== Point.emptyValues.value) {
              out.push(row[l]); // we know there's no neighbor match, push val to output
              l++;
            }
            while (row[l] === Point.emptyValues.value) l++; // we don't care about nulls
            r++;
          }
        }

        while (out.length < row.length) out.push(Point.emptyValues.value);
        
        return out;
      }

      _mergeRows (grid) {
        return grid.map(this._mergeRow);
      }

      _compareStates (prev, curr) {
        for (let i = 0; i < Math.max(prev.length, curr.length); i++) {
          for (let j = 0; j < Math.max(prev.length, curr.length); j++) {
            if (prev[i][j] !== curr[i][j]) return true;
          }
        }

        return false;
      }

      _mergeUp () {
        const rotated = rotateMatrixCounterClockwise(this._data)
        const merged = this._mergeRows(rotated);
        return rotateMatrixClockwise(merged);
      }

      _mergeLeft () {
        const merged = this._mergeRows(this._data);
        return merged;
      }

      _mergeDown () {
        const rotated = rotateMatrixClockwise(this._data);
        const merged = this._mergeRows(rotated);
        return rotateMatrixCounterClockwise(merged);
      }

      _mergeRight () {
        const merged = this._mergeRows(rotateMatrixDouble(this._data));
        return rotateMatrixDouble(merged);
      }

      _calculateStateFromSwipe (direction) {
        // call swipe direction
        let updatedState;
        switch (direction) {
          case 'up':
            updatedState = this._mergeUp();
            break;
          case 'left':
            updatedState = this._mergeLeft();
            break;
          case 'down':
            updatedState = this._mergeDown();
            break;
          case 'right':
            updatedState = this._mergeRight();
            break;
          default:
            throw new Error(`Invalid Action: ${ direction }`);
        }

        return updatedState;
      }

      _hasLost () {
        // if there are no nulls && no mergeable neighbors, user has lost
        const matrix = this.data;
        const Y_BOUND = matrix.length;
        const X_BOUND = matrix[0].length;
        
        for (let y = 0; y < Y_BOUND; y++) {
          for (let x = 0; x < X_BOUND; x++) {
            const curr = matrix[y][x];

            // NOTE: avoid out of bounds/reference errors on access
            //  - can't use `null` as that is the data value for 'empty space'
            const u = y !== 0 ? matrix[y-1][x] : undefined,
                  l = x !== 0 ? matrix[y][x-1] : undefined,
                  d = y !== Y_BOUND-1 ? matrix[y+1][x] : undefined,
                  r = x !== X_BOUND-1 ? matrix[y][x+1] : undefined;

            if (curr === u || curr === l || curr === d || curr === r || curr === Point.emptyValues.value) return false;
          }
        }

        return true;
      }

      _setModal (message) {
        this.modal.dispatchEvent(new CustomEvent(Board.modalEvt, { detail: { message } }));
      }

      _modalOpen () {
        this._setModal('OPEN');
      }

      _modalClose () {
        this._setModal('CLOSE');
      }

      // PUBLIC METHODS
      reset () {
        this._data = this.constructor.resetData();
        this.render();
        this._modalClose();
      }

      handleSwipeEvent (evt) {
        evt.preventDefault();
        // determine direction
        const dir = evt.currentTarget.value
        // call swipe
        this.swipe(dir);
      }

      swipe (direction) {
        if (!direction) throw new Error(`No/Invalid swipe direction provided: ${ direction }`);
        // capture current data
        const prevState = this._data;
        // get new state
        const newState = this._calculateStateFromSwipe(direction)
        this.data = newState; // TODO: move to an updateState()?

        const hasLost = this._hasLost();
        if (hasLost) return this.end();
        // compare prev to current
        const shouldIntroduce = this._compareStates(prevState, newState);
        // if different, introduce
        if (shouldIntroduce) this._introduce();
        // assess win/lose status
        this.render();
      }

      end () {
        // prevent any more game progress
        // show lost modal
        this._modalOpen();
      }

      render () {
        for (let i = 0; i < this._data.length; i++) {
          for (let j = 0; j < this._data.length; j++) {
            const idx = (this._data.length * i) + j; // number 0-15
            const point = this._points[idx];
            point.render(this._data[i][j]);
          }
        }
      }
    }

    class App {
      constructor () {
        this.board = new Board();
        // this.swipeUpEl = document.querySelector('#swipe-up');
        // this.swipeLeftEl = document.querySelector('#swipe-left');
        // this.swipeDownEl = document.querySelector('#swipe-down');
        // this.swipeRightEl = document.querySelector('#swipe-right');
        this.swipeBtnEls = [].slice.call(document.querySelectorAll('.js-swipe-btn'));
        this.resetEls = [].slice.call(document.querySelectorAll('.js-reset-btn'));

        this._addListeners();
      }

      _addListeners () {
        const handleSwipe = this.board.handleSwipeEvent.bind(this.board);

        // this.swipeUpEl.addEventListener('click', handleSwipe)
        // this.swipeLeftEl.addEventListener('click', handleSwipe)
        // this.swipeDownEl.addEventListener('click', handleSwipe)
        // this.swipeRightEl.addEventListener('click', handleSwipe)
        this.swipeBtnEls.forEach(el => el.addEventListener('click', handleSwipe))

        this.resetEls.forEach(el => el.addEventListener('click', (e) => {
          e.preventDefault();
          this.board.reset();
        }))
      }
    }

    window.onload = () => {
      const app = new App();
    };
  </script>
</body>

</html>
