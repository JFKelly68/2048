<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 Clone</title>
  <style>
    .grid-3x3 {
      display: grid;
      grid-template-columns: 1fr 5fr 1fr;
      grid-template-rows: 1fr 5fr 1fr;
    }

    .top-m,
    .mid-l,
    .mid-r,
    .bot-m {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(4, minmax(100px, 1fr));
      grid-auto-rows: minmax(100px, auto);
    }

    .point {
      display: grid;
      align-items: center;
      justify-items: center;
      border: 1px solid #000;
    }
    
    .swipe {
      position: relative;
      width: 80px;
      height: 40px;
    }

    .swipe::after {
      content: '^';
      display: flex;
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      align-items: center;
      justify-content: center;
      transform-origin: center;
    }

    .swipe-l {
      transform: rotate(-90deg);
    }
    .swipe-r {
      transform: rotate(90deg);
    }
    .swipe-d {
      transform: rotate(180deg);
    }

    header,
    footer {
      text-align: center;
    }

    div[value="1"] {
      background-color: rgb(240, 240, 240);
    }
    div[value="2"] {
      background-color: silver;
    }
    div[value="4"] {
      background-color: beige;
    }
    div[value="8"] {
      background-color: yellow;
    }
    div[value="16"] {
      background-color: rgb(215, 185, 110);
    }
    div[value="32"] {
      background-color: orange;
    }
    div[value="64"] {
      background-color: rgb(255, 125, 33);
    }
    div[value="128"] {
      background-color: rgb(26, 215, 221);
    }
    div[value="256"] {
      background-color: rgb(0, 255, 166);
    }
    div[value="512"] {
      background-color: rgb(17, 189, 40);
    }
    div[value="1024"] {
      background-color: rgb(20, 129, 7);
    }
    div[value="2048"] {
      background-color: rgb(252, 0, 0);
    }
  </style>
</head>
<body>
  <article>
    <header>
      This is a clone 2048 game
    </header>
    <section id="main" class="grid-3x3">
      <div class="top-l"></div>
      <div class="top-m">
        <button type="button" class="swipe swipe-u" id="swipe-up" value="up"></button>
      </div>
      <div class="top-r"></div>
      <div class="mid-l">
        <!-- BOARD goes here -->
        <button type="button" class="swipe swipe-l" id="swipe-left" value="left"></button>
      </div>
      <div class="mid-m">
        <div id="board" class="board"></div>
      </div>
      <div class="mid-r">
        <button type="button" class="swipe swipe-r" id="swipe-right" value="right"></button>
      </div>
      <div class="bot-l"></div>
      <div class="bot-m">
        <button type="button" class="swipe swipe-d" id="swipe-down" value="down"></button>
      </div>
      <div class="bot-r"></div>
    </section>
    <footer>
      <!-- reset button -->
      <button type="button" id="reset">Reset</button>
    </footer>
  </article>
  
  <script type="text/javascript">
    // UTILS
    const compose = (a, b) => x => a(b(x));
    const reverse = array => [...array].reverse();
    const flipMatrix = matrix => (
      matrix[0].map((column, index) => (
        matrix.map(row => row[index])
      ))
    );
    const rotateMatrixClockwise = compose(flipMatrix, reverse);
    const rotateMatrixCounterClockwise = compose(reverse, flipMatrix)
    const rotateHalf = compose(rotateMatrixClockwise, rotateMatrixClockwise);

    class Point {
      static get className () {
        return 'point';
      }

      static makeElement () {
        const el = document.createElement('div');
        el.classList.add(`${this.className}`);
        return el;
      }

      static get emptyValues () {
        return {
          display: '',
          attribute: 'empty',
          value: null // don't make this a number
        };
      }

      constructor (val) {
        this.element = this.constructor.makeElement();
        this.render(val);
      }

      render (value) {
        this.element.setAttribute('value', value || this.constructor.emptyValues.attribute);
        this.element.innerText = value || this.constructor.emptyValues.display;
      }
    }

    class Board {
      static get className () {
        return 'board'
      }

      static get selector () {
        return `#${this.className}`;
      }

      static resetData (size = 4) {
        // NOTE: create square matrix
        return Array.from({length: size}, () => Array.from({length: size}, () => Math.random() > 0.8 ? 2 : null)) // initialize grid with 0's
      }
      
      constructor (initData) {
        this.element = document.querySelector(this.constructor.selector);
        this._data = initData;
        this._points = [];

        this._init();
      }
      
      // PRIVATE METHODS
      _init () {
        if (!this._data) this._data = this.constructor.resetData(); // only update data if none initialized
        if (!this.element.children.length) this._makeGrid();
        this.render();
      }

      _introduce () {
        // take the existing data and add a new 2 or 4 to an available slot
        const newNum = Math.random() > 0.4 ? 2 : 4; // trend towards 2s
        const availableSpaces = this._assessAvailable();
        const idx = Math.round(Math.random() * availableSpaces.length) % availableSpaces.length; // random int based on # of available spaces
        const [x,y] = availableSpaces[idx]; // get matrix coordinates of available space chosen at random
        this._data[x][y] = newNum;
      }

      _assessAvailable () {
        const availableSpaces = [];
        
        for (let i = 0; i < this._data.length; i++) {
          for (let j = 0; j < this._data.length; j++) {
            if (this._data[i][j] === Point.emptyValues.value) availableSpaces.push([i,j]);
          }
        }

        return availableSpaces;
      }

      _rebuild () {
        this._deleteGrid();
        this.reset();
      }

      _deleteGrid () {
        if (this.element.children.length) [].slice.call(this.element.children).forEach(el => el.remove());
      }

      _makeGrid () {
        this._deleteGrid();
        const points = this._data.flat().map(val => new Point(val))
        this.element.append(...points.map(p => p.element));
        this._points = points;
      }
      
      
      /* NOTE: previous, naive implementation (does not work for instance such as [2,0,2,0])
        for (let i = 0; i < row.length; i++) {
          if (!row[i]) continue; // if it's 0, skip
          if (row[i] == row[i+1]) {
            out.push(row[i] + row[i+1]);
            i++;
          }
          else {
            out.push(row[i]);
          }
        }
      */
      _mergeRow (row) {
        const out = [];
        let l = 0, r = 1; // 2 pointers

        /* NOTE: O(n) I believe, single-pass consolidation
          increment r and compare to l
          we don't care about 0s, so while r == 0, increment
          if l === r
            push sum to output
            move l to right of r
            move r+1
          else (l !== r)
            if l !== 0 && !undefined (i.e. !out of bounds)
              push l to output
              increment l
            (because we don't care about 0s) while l == 0, increment
            increment r
        */    
        while (l < row.length) {
          while (row[r] === Point.emptyValues.value) r++;
          if (row[l] === row[r]) {
            out.push(row[l] + row[r]);
            l = ++r;
            r++;
          } else {
            if (row[l] !== Point.emptyValues.value) {
              out.push(row[l]); // we know there's no neighbor match, push val to output
              l++;
            }
            while (row[l] === Point.emptyValues.value) l++; // we don't care about 0s
            r++;
          }
        }

        while (out.length < row.length) out.push(Point.emptyValues.value);
        
        return out;
      }

      _mergeRows (grid) {
        return grid.map(this._mergeRow);
      }

      // PUBLIC METHODS
      reset () {
        this._data = this.constructor.resetData();
        this.render();
      }

      swipeLeft () {
        const merged = this._mergeRows(this._data);
        this._data = merged;
        this.render();
      }

      swipeRight () {
        const merged = this._mergeRows(rotateHalf(this._data));
        this._data = rotateHalf(merged); // reset to original 
        this.render();
      }

      swipeUp () {
        const rotated = rotateMatrixCounterClockwise(this._data)
        const merged = this._mergeRows(rotated);
        this._data = rotateMatrixClockwise(merged); // reset to original
        this.render();
      }

      swipeDown () {
        const rotated = rotateMatrixClockwise(this._data);
        const merged = this._mergeRows(rotated);
        this._data = rotateMatrixCounterClockwise(merged);
        this.render();
      }

      render () {
        this._introduce(); // TODO: might want to move this out of the render() for separation of concerns

        for (let i = 0; i < this._data.length; i++) {
          for (let j = 0; j < this._data.length; j++) {
            const idx = (this._data.length * i) + j; // number 0-15
            const point = this._points[idx];
            point.render(this._data[i][j]);
          }
        }
      }

    }

    class App {
      constructor () {
        this.board = new Board();
        this.swipeUpEl = document.querySelector('#swipe-up');
        this.swipeLeftEl = document.querySelector('#swipe-left');
        this.swipeDownEl = document.querySelector('#swipe-down');
        this.swipeRightEl = document.querySelector('#swipe-right');
        this.resetEl = document.querySelector('#reset');

        this._addListeners();
      }

      _addListeners () {
        const handleSwipeUp = this.board.swipeUp.bind(this.board);
        const handleSwipeLeft = this.board.swipeLeft.bind(this.board);
        const handleSwipeDown = this.board.swipeDown.bind(this.board);
        const handleSwipeRight = this.board.swipeRight.bind(this.board);

        this.swipeUpEl.addEventListener('click', handleSwipeUp)
        this.swipeLeftEl.addEventListener('click', handleSwipeLeft)
        this.swipeDownEl.addEventListener('click', handleSwipeDown)
        this.swipeRightEl.addEventListener('click', handleSwipeRight)

        this.resetEl.addEventListener('click', (e) => {
          e.preventDefault();
          this.board.reset();
        })
      }
    }

    window.onload = () => {
      const app = new App();
    };
  </script>
</body>

</html>